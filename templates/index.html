// ... (이전 코드 동일)

async function giveUp() {
    // 사용자에게 한 번 더 확인
    if (!confirm("정말 이번 문제를 포기하시겠습니까? (티어 하락 및 스트릭 감소)")) return;

    if (state.streak > 0) {
        // 스트릭이 있으면 1 감소하고 티어 하락 후 새 문제
        state.streak--;
        state.tier = Math.max(1, state.tier - 1);
        alert(`포기하셨습니다. 스트릭 1 감소 (현재: ${state.streak}), 티어 하락.`);
        await fetchProblem(); // 즉시 다음 문제로 진행
    } else {
        // 스트릭이 0인 상태에서 포기해도 초기화 대신 '재도전' 기회를 줌
        alert("스트릭이 0입니다. 티어만 하락하며 게임을 계속 진행합니다.");
        state.tier = Math.max(1, state.tier - 1);
        await fetchProblem(); // 초기화(forceReset) 대신 새 문제를 불러옴
    }
}

// 기존 forceReset은 'Reset Game' 버튼을 눌렀을 때만 명시적으로 작동하게 유지
function forceReset() {
    clearInterval(window.timerInt);
    state = { isPlaying: false, tier: 13, streak: 0, handle: '', startTime: null, prob: null, isSolved: false };
    localStorage.removeItem('ud_save');
    document.getElementById('game-area').classList.add('hidden');
    document.getElementById('streak-ui').classList.add('hidden');
    document.getElementById('setup-area').classList.remove('hidden');
    // document.getElementById('handle').value = ''; // 아이디는 남겨두는게 편합니다.
}

// 시간 초과 시에도 자동으로 giveUp을 호출하므로 위 로직이 적용됩니다.
function startTimer() {
    clearInterval(window.timerInt);
    window.timerInt = setInterval(() => {
        const remain = 3600 - Math.floor((Date.now() - state.startTime) / 1000);
        if(remain <= 0) { 
            clearInterval(window.timerInt);
            alert("시간 초과! 다음 문제로 넘어갑니다."); 
            giveUp(); // 여기서 위에서 수정한 giveUp이 실행됩니다.
        }
        const m = Math.floor(remain/60);
        const s = (remain%60).toString().padStart(2,'0');
        document.getElementById('timer').innerText = `${m}:${s}`;
    }, 1000);
}
